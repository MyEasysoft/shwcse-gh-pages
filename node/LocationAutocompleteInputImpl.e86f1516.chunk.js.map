{"version":3,"file":"LocationAutocompleteInputImpl.e86f1516.chunk.js","mappings":"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","sources":["webpack://app/./src/components/LocationAutocompleteInput/LocationAutocompleteInput.module.css?a670","components/LocationAutocompleteInput/IconHourGlass.js","components/LocationAutocompleteInput/IconCurrentLocation.js","components/LocationAutocompleteInput/GeocoderMapbox.js","components/LocationAutocompleteInput/GeocoderGoogleMaps.js","components/LocationAutocompleteInput/LocationAutocompleteInputImpl.js","util/googleMaps.js"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport default {\"root\":\"LocationAutocompleteInput_root__C33Xn\",\"icon\":\"LocationAutocompleteInput_icon__05Eu7\",\"iconSvg\":\"LocationAutocompleteInput_iconSvg__ZBozF\",\"iconSvgGroup\":\"LocationAutocompleteInput_iconSvgGroup__ZVPyL\",\"iconSpinner\":\"LocationAutocompleteInput_iconSpinner__qTgyR\",\"input\":\"LocationAutocompleteInput_input__dNBGc\",\"predictionsRoot\":\"LocationAutocompleteInput_predictionsRoot__IdlJx\",\"predictionsRootGoogle\":\"LocationAutocompleteInput_predictionsRootGoogle__Xf2kH\",\"predictionsRootMapbox\":\"LocationAutocompleteInput_predictionsRootMapbox__Zr6UD\",\"poweredByGoogle\":\"LocationAutocompleteInput_poweredByGoogle__pGmSt\",\"predictions\":\"LocationAutocompleteInput_predictions__v8sKL marketplaceBodyFontStyles\",\"highlighted\":\"LocationAutocompleteInput_highlighted__NKrMp\",\"currentLocation\":\"LocationAutocompleteInput_currentLocation__CHnR6 p\",\"currentLocationIcon\":\"LocationAutocompleteInput_currentLocationIcon__2uXoi\"};","import React from 'react';\r\n\r\nimport css from './LocationAutocompleteInput.module.css';\r\n\r\nconst IconHourGlass = () => (\r\n  <svg\r\n    className={css.iconSvg}\r\n    width=\"21\"\r\n    height=\"22\"\r\n    viewBox=\"0 0 21 22\"\r\n    xmlns=\"http://www.w3.org/2000/svg\"\r\n  >\r\n    <g\r\n      className={css.iconSvgGroup}\r\n      transform=\"matrix(-1 0 0 1 20 1)\"\r\n      strokeWidth=\"2\"\r\n      fill=\"none\"\r\n      fillRule=\"evenodd\"\r\n      strokeLinecap=\"round\"\r\n      strokeLinejoin=\"round\"\r\n    >\r\n      <path d=\"M13 14l5.241 5.241\" />\r\n      <circle cx=\"7.5\" cy=\"7.5\" r=\"7.5\" />\r\n    </g>\r\n  </svg>\r\n);\r\n\r\nexport default IconHourGlass;\r\n","import React from 'react';\r\n\r\nimport css from './LocationAutocompleteInput.module.css';\r\n\r\nconst IconCurrentLocation = () => (\r\n  <svg\r\n    className={css.currentLocationIcon}\r\n    width=\"12\"\r\n    height=\"12\"\r\n    xmlns=\"http://www.w3.org/2000/svg\"\r\n  >\r\n    <path\r\n      d=\"M11.9269636.07279915c-.0779984-.0770013-.1959959-.0950016-.2924939-.04400074L.13470842 6.02889945c-.10199788.05300089-.15499678.16900284-.12749735.28100473.02799942.11150188.12799734.1900032.24299496.1900032h5.249891v5.25008842c0 .1150019.07899836.2160036.19049604.2430041C5.71009267 11.998 5.73059224 12 5.75009184 12c.0914981 0 .1779963-.0505009.22199539-.1345023L11.9719627.36530407c.0499989-.09650162.0319993-.21500362-.0449991-.29250492\"\r\n      fill=\"#FFF\"\r\n      fillRule=\"evenodd\"\r\n    />\r\n  </svg>\r\n);\r\n\r\nexport default IconCurrentLocation;\r\n","import { types as sdkTypes } from '../../util/sdkLoader';\r\nimport { userLocation } from '../../util/maps';\r\n\r\nconst { LatLng: SDKLatLng, LatLngBounds: SDKLatLngBounds } = sdkTypes;\r\n\r\nexport const CURRENT_LOCATION_ID = 'current-location';\r\n\r\nconst GENERATED_BOUNDS_DEFAULT_DISTANCE = 500; // meters\r\n// Distances for generated bounding boxes for different Mapbox place types\r\nconst PLACE_TYPE_BOUNDS_DISTANCES = {\r\n  address: 500,\r\n  country: 2000,\r\n  region: 2000,\r\n  postcode: 2000,\r\n  district: 2000,\r\n  place: 2000,\r\n  locality: 2000,\r\n  neighborhood: 2000,\r\n  poi: 2000,\r\n  'poi.landmark': 2000,\r\n};\r\n\r\nconst locationBounds = (latlng, distance) => {\r\n  if (!latlng) {\r\n    return null;\r\n  }\r\n\r\n  const bounds = new window.mapboxgl.LngLat(latlng.lng, latlng.lat).toBounds(distance);\r\n  return new SDKLatLngBounds(\r\n    new SDKLatLng(bounds.getNorth(), bounds.getEast()),\r\n    new SDKLatLng(bounds.getSouth(), bounds.getWest())\r\n  );\r\n};\r\n\r\nconst placeOrigin = prediction => {\r\n  if (prediction && Array.isArray(prediction.center) && prediction.center.length === 2) {\r\n    // Coordinates in Mapbox features are represented as [longitude, latitude].\r\n    return new SDKLatLng(prediction.center[1], prediction.center[0]);\r\n  }\r\n  return null;\r\n};\r\n\r\nconst placeBounds = prediction => {\r\n  if (prediction) {\r\n    if (Array.isArray(prediction.bbox) && prediction.bbox.length === 4) {\r\n      // Bounds in Mapbox features are represented as [minX, minY, maxX, maxY]\r\n      return new SDKLatLngBounds(\r\n        new SDKLatLng(prediction.bbox[3], prediction.bbox[2]),\r\n        new SDKLatLng(prediction.bbox[1], prediction.bbox[0])\r\n      );\r\n    } else {\r\n      // If bounds are not available, generate them around the origin\r\n\r\n      // Resolve bounds distance based on place type\r\n      const placeType = Array.isArray(prediction.place_type) && prediction.place_type[0];\r\n\r\n      const distance =\r\n        (placeType && PLACE_TYPE_BOUNDS_DISTANCES[placeType]) || GENERATED_BOUNDS_DEFAULT_DISTANCE;\r\n\r\n      return locationBounds(placeOrigin(prediction), distance);\r\n    }\r\n  }\r\n  return null;\r\n};\r\n\r\nexport const GeocoderAttribution = () => null;\r\n\r\n/**\r\n * A forward geocoding (place name -> coordinates) implementation\r\n * using the Mapbox Geocoding API.\r\n */\r\nclass GeocoderMapbox {\r\n  getClient() {\r\n    const libLoaded = typeof window !== 'undefined' && window.mapboxgl && window.mapboxSdk;\r\n    if (!libLoaded) {\r\n      throw new Error('Mapbox libraries are required for GeocoderMapbox');\r\n    }\r\n    if (!this._client) {\r\n      this._client = window.mapboxSdk({\r\n        accessToken: window.mapboxgl.accessToken,\r\n      });\r\n    }\r\n    return this._client;\r\n  }\r\n\r\n  // Public API\r\n  //\r\n\r\n  /**\r\n   * Search places with the given name.\r\n   *\r\n   * @param {String} search query for place names\r\n   *\r\n   * @return {Promise<{ search: String, predictions: Array<Object>}>}\r\n   * results of the geocoding, should have the original search query\r\n   * and an array of predictions. The format of the predictions is\r\n   * only relevant for the `getPlaceDetails` function below.\r\n   */\r\n  getPlacePredictions(search, countryLimit, locale) {\r\n    const limitCountriesMaybe = countryLimit ? { countries: countryLimit } : {};\r\n\r\n    return this.getClient()\r\n      .geocoding.forwardGeocode({\r\n        query: search,\r\n        limit: 5,\r\n        ...limitCountriesMaybe,\r\n        language: [locale],\r\n      })\r\n      .send()\r\n      .then(response => {\r\n        return {\r\n          search,\r\n          predictions: response.body.features,\r\n        };\r\n      });\r\n  }\r\n\r\n  /**\r\n   * Get the ID of the given prediction.\r\n   */\r\n  getPredictionId(prediction) {\r\n    return prediction.id;\r\n  }\r\n\r\n  /**\r\n   * Get the address text of the given prediction.\r\n   */\r\n  getPredictionAddress(prediction) {\r\n    if (prediction.predictionPlace) {\r\n      // default prediction defined above\r\n      return prediction.predictionPlace.address;\r\n    }\r\n    // prediction from Mapbox geocoding API\r\n    return prediction.place_name;\r\n  }\r\n\r\n  /**\r\n   * Fetch or read place details from the selected prediction.\r\n   *\r\n   * @param {Object} prediction selected prediction object\r\n   *\r\n   * @return {Promise<util.propTypes.place>} a place object\r\n   */\r\n  getPlaceDetails(prediction, currentLocationBoundsDistance) {\r\n    if (this.getPredictionId(prediction) === CURRENT_LOCATION_ID) {\r\n      return userLocation().then(latlng => {\r\n        return {\r\n          address: '',\r\n          origin: latlng,\r\n          bounds: locationBounds(latlng, currentLocationBoundsDistance),\r\n        };\r\n      });\r\n    }\r\n\r\n    if (prediction.predictionPlace) {\r\n      return Promise.resolve(prediction.predictionPlace);\r\n    }\r\n\r\n    return Promise.resolve({\r\n      address: this.getPredictionAddress(prediction),\r\n      origin: placeOrigin(prediction),\r\n      bounds: placeBounds(prediction),\r\n    });\r\n  }\r\n}\r\n\r\nexport default GeocoderMapbox;\r\n","import React from 'react';\r\nimport classNames from 'classnames';\r\nimport * as googleMapsUtil from '../../util/googleMaps';\r\nimport { userLocation } from '../../util/maps';\r\n\r\nimport css from './LocationAutocompleteInput.module.css';\r\n\r\nexport const CURRENT_LOCATION_ID = 'current-location';\r\n\r\n// When displaying data from the Google Maps Places API, and\r\n// attribution is required next to the results.\r\n// See: https://developers.google.com/places/web-service/policies#powered\r\nexport const GeocoderAttribution = props => {\r\n  const { rootClassName, className } = props;\r\n  const classes = classNames(rootClassName || css.poweredByGoogle, className);\r\n  return <div className={classes} />;\r\n};\r\n\r\n/**\r\n * A forward geocoding (place name -> coordinates) implementation\r\n * using the Google Maps Places API.\r\n */\r\nclass GeocoderGoogleMaps {\r\n  constructor() {\r\n    this.sessionToken = null;\r\n  }\r\n  getSessionToken() {\r\n    this.sessionToken =\r\n      this.sessionToken || new window.google.maps.places.AutocompleteSessionToken();\r\n    return this.sessionToken;\r\n  }\r\n\r\n  // Public API\r\n  //\r\n\r\n  /**\r\n   * Search places with the given name.\r\n   *\r\n   * @param {String} search query for place names\r\n   *\r\n   * @return {Promise<{ search: String, predictions: Array<Object>}>}\r\n   * results of the geocoding, should have the original search query\r\n   * and an array of predictions. The format of the predictions is\r\n   * only relevant for the `getPlaceDetails` function below.\r\n   */\r\n  getPlacePredictions(search, countryLimit) {\r\n    const limitCountriesMaybe = countryLimit\r\n      ? {\r\n          componentRestrictions: {\r\n            country: countryLimit,\r\n          },\r\n        }\r\n      : {};\r\n\r\n    return googleMapsUtil\r\n      .getPlacePredictions(search, this.getSessionToken(), limitCountriesMaybe)\r\n      .then(results => {\r\n        return {\r\n          search,\r\n          predictions: results.predictions,\r\n        };\r\n      });\r\n  }\r\n\r\n  /**\r\n   * Get the ID of the given prediction.\r\n   */\r\n  getPredictionId(prediction) {\r\n    if (prediction.predictionPlace) {\r\n      // default prediction defined above\r\n      return prediction.id;\r\n    }\r\n    // prediction from Google Maps Places API\r\n    return prediction.place_id;\r\n  }\r\n\r\n  /**\r\n   * Get the address text of the given prediction.\r\n   */\r\n  getPredictionAddress(prediction) {\r\n    if (prediction.predictionPlace) {\r\n      // default prediction defined above\r\n      return prediction.predictionPlace.address;\r\n    }\r\n    // prediction from Google Maps Places API\r\n    return prediction.description;\r\n  }\r\n\r\n  /**\r\n   * Fetch or read place details from the selected prediction.\r\n   *\r\n   * @param {Object} prediction selected prediction object\r\n   *\r\n   * @return {Promise<util.propTypes.place>} a place object\r\n   */\r\n  getPlaceDetails(prediction, currentLocationBoundsDistance) {\r\n    if (this.getPredictionId(prediction) === CURRENT_LOCATION_ID) {\r\n      return userLocation().then(latlng => {\r\n        return {\r\n          address: '',\r\n          origin: latlng,\r\n          bounds: googleMapsUtil.locationBounds(latlng, currentLocationBoundsDistance),\r\n        };\r\n      });\r\n    }\r\n\r\n    if (prediction.predictionPlace) {\r\n      return Promise.resolve(prediction.predictionPlace);\r\n    }\r\n\r\n    return googleMapsUtil\r\n      .getPlaceDetails(prediction.place_id, this.getSessionToken())\r\n      .then(place => {\r\n        this.sessionToken = null;\r\n        return place;\r\n      });\r\n  }\r\n}\r\n\r\nexport default GeocoderGoogleMaps;\r\n","import React, { Component } from 'react';\r\nimport {\r\n  any,\r\n  arrayOf,\r\n  bool,\r\n  func,\r\n  number,\r\n  shape,\r\n  string,\r\n  oneOfType,\r\n  object,\r\n  node,\r\n} from 'prop-types';\r\nimport classNames from 'classnames';\r\nimport debounce from 'lodash/debounce';\r\n\r\nimport { useConfiguration } from '../../context/configurationContext';\r\nimport { FormattedMessage } from '../../util/reactIntl';\r\nimport { propTypes } from '../../util/types';\r\n\r\nimport { IconSpinner } from '../../components';\r\n\r\nimport IconHourGlass from './IconHourGlass';\r\nimport IconCurrentLocation from './IconCurrentLocation';\r\nimport * as geocoderMapbox from './GeocoderMapbox';\r\nimport * as geocoderGoogleMaps from './GeocoderGoogleMaps';\r\n\r\nimport css from './LocationAutocompleteInput.module.css';\r\n\r\nconst DEBOUNCE_WAIT_TIME = 300;\r\nconst DEBOUNCE_WAIT_TIME_FOR_SHORT_QUERIES = 1000;\r\nconst KEY_CODE_ARROW_UP = 38;\r\nconst KEY_CODE_ARROW_DOWN = 40;\r\nconst KEY_CODE_ENTER = 13;\r\nconst KEY_CODE_TAB = 9;\r\nconst KEY_CODE_ESC = 27;\r\nconst DIRECTION_UP = 'up';\r\nconst DIRECTION_DOWN = 'down';\r\nconst TOUCH_TAP_RADIUS = 5; // Movement within 5px from touch start is considered a tap\r\n\r\n// Touch devices need to be able to distinguish touches for scrolling and touches to tap\r\nconst getTouchCoordinates = nativeEvent => {\r\n  const touch = nativeEvent && nativeEvent.changedTouches ? nativeEvent.changedTouches[0] : null;\r\n  return touch ? { x: touch.screenX, y: touch.screenY } : null;\r\n};\r\n\r\n// Get correct geocoding variant: geocoderGoogleMaps or geocoderMapbox\r\nconst getGeocoderVariant = mapProvider => {\r\n  const isGoogleMapsInUse = mapProvider === 'googleMaps';\r\n  return isGoogleMapsInUse ? geocoderGoogleMaps : geocoderMapbox;\r\n};\r\n\r\n// Renders the autocompletion prediction results in a list\r\nconst LocationPredictionsList = props => {\r\n  const {\r\n    rootClassName,\r\n    className,\r\n    children,\r\n    predictions,\r\n    currentLocationId,\r\n    geocoder,\r\n    isGoogleMapsInUse,\r\n    highlightedIndex,\r\n    onSelectStart,\r\n    onSelectMove,\r\n    onSelectEnd,\r\n  } = props;\r\n  if (predictions.length === 0) {\r\n    return null;\r\n  }\r\n\r\n  const item = (prediction, index) => {\r\n    const isHighlighted = index === highlightedIndex;\r\n    const predictionId = geocoder.getPredictionId(prediction);\r\n\r\n    return (\r\n      <li\r\n        className={isHighlighted ? css.highlighted : null}\r\n        key={predictionId}\r\n        onTouchStart={e => {\r\n          e.preventDefault();\r\n          onSelectStart(getTouchCoordinates(e.nativeEvent));\r\n        }}\r\n        onMouseDown={e => {\r\n          e.preventDefault();\r\n          onSelectStart();\r\n        }}\r\n        onTouchMove={e => {\r\n          e.preventDefault();\r\n          onSelectMove(getTouchCoordinates(e.nativeEvent));\r\n        }}\r\n        onTouchEnd={e => {\r\n          e.preventDefault();\r\n          onSelectEnd(prediction);\r\n        }}\r\n        onMouseUp={e => {\r\n          e.preventDefault();\r\n          onSelectEnd(prediction);\r\n        }}\r\n      >\r\n        {predictionId === currentLocationId ? (\r\n          <span className={css.currentLocation}>\r\n            <IconCurrentLocation />\r\n            <FormattedMessage id=\"LocationAutocompleteInput.currentLocation\" />\r\n          </span>\r\n        ) : (\r\n          geocoder.getPredictionAddress(prediction)\r\n        )}\r\n      </li>\r\n    );\r\n  };\r\n\r\n  const predictionRootMapProviderClass = isGoogleMapsInUse\r\n    ? css.predictionsRootGoogle\r\n    : css.predictionsRootMapbox;\r\n  const classes = classNames(\r\n    rootClassName || css.predictionsRoot,\r\n    predictionRootMapProviderClass,\r\n    className\r\n  );\r\n\r\n  return (\r\n    <div className={classes}>\r\n      <ul className={css.predictions}>{predictions.map(item)}</ul>\r\n      {children}\r\n    </div>\r\n  );\r\n};\r\n\r\nLocationPredictionsList.defaultProps = {\r\n  rootClassName: null,\r\n  className: null,\r\n  highlightedIndex: null,\r\n};\r\n\r\nLocationPredictionsList.propTypes = {\r\n  rootClassName: string,\r\n  className: string,\r\n  children: node,\r\n  predictions: arrayOf(object).isRequired,\r\n  currentLocationId: string.isRequired,\r\n  geocoder: object.isRequired,\r\n  highlightedIndex: number,\r\n  onSelectStart: func.isRequired,\r\n  onSelectMove: func.isRequired,\r\n  onSelectEnd: func.isRequired,\r\n};\r\n\r\n// Get the current value with defaults from the given\r\n// LocationAutocompleteInput props.\r\nconst currentValue = props => {\r\n  const value = props.input.value || {};\r\n  const { search = '', predictions = [], selectedPlace = null } = value;\r\n  return { search, predictions, selectedPlace };\r\n};\r\n\r\n/*\r\n  Location auto completion input component\r\n\r\n  This component can work as the `component` prop to Final Form's\r\n  <Field /> component. It takes a custom input value shape, and\r\n  controls the onChange callback that is called with the input value.\r\n\r\n  The component works by listening to the underlying input component\r\n  and calling a Geocoder implementation for predictions. When the\r\n  predictions arrive, those are passed to Final Form in the onChange\r\n  callback.\r\n\r\n  See the LocationAutocompleteInput.example.js file for a usage\r\n  example within a form.\r\n*/\r\nclass LocationAutocompleteInputImplementation extends Component {\r\n  constructor(props) {\r\n    super(props);\r\n\r\n    this._isMounted = false;\r\n\r\n    this.state = {\r\n      inputHasFocus: false,\r\n      selectionInProgress: false,\r\n      touchStartedFrom: null,\r\n      highlightedIndex: -1, // -1 means no highlight\r\n      fetchingPlaceDetails: false,\r\n      fetchingPredictions: false,\r\n    };\r\n\r\n    // Ref to the input element.\r\n    this.input = null;\r\n    this.shortQueryTimeout = null;\r\n\r\n    this.getGeocoder = this.getGeocoder.bind(this);\r\n    this.currentPredictions = this.currentPredictions.bind(this);\r\n    this.changeHighlight = this.changeHighlight.bind(this);\r\n    this.selectPrediction = this.selectPrediction.bind(this);\r\n    this.selectItemIfNoneSelected = this.selectItemIfNoneSelected.bind(this);\r\n    this.onKeyDown = this.onKeyDown.bind(this);\r\n    this.onChange = this.onChange.bind(this);\r\n    this.handleOnBlur = this.handleOnBlur.bind(this);\r\n    this.handlePredictionsSelectStart = this.handlePredictionsSelectStart.bind(this);\r\n    this.handlePredictionsSelectMove = this.handlePredictionsSelectMove.bind(this);\r\n    this.handlePredictionsSelectEnd = this.handlePredictionsSelectEnd.bind(this);\r\n    this.finalizeSelection = this.finalizeSelection.bind(this);\r\n\r\n    // Debounce the method to avoid calling the API too many times\r\n    // when the user is typing fast.\r\n    this.predict = debounce(this.predict.bind(this), DEBOUNCE_WAIT_TIME, { leading: true });\r\n  }\r\n\r\n  componentDidMount() {\r\n    this._isMounted = true;\r\n  }\r\n\r\n  componentWillUnmount() {\r\n    window.clearTimeout(this.shortQueryTimeout);\r\n    this._isMounted = false;\r\n  }\r\n\r\n  getGeocoder() {\r\n    const geocoderVariant = getGeocoderVariant(this.props.config.maps.mapProvider);\r\n    const Geocoder = geocoderVariant.default;\r\n\r\n    // Create the Geocoder as late as possible only when it is needed.\r\n    if (!this._geocoder) {\r\n      this._geocoder = new Geocoder();\r\n    }\r\n    return this._geocoder;\r\n  }\r\n\r\n  currentPredictions() {\r\n    const { search, predictions: fetchedPredictions } = currentValue(this.props);\r\n    const { useDefaultPredictions, config } = this.props;\r\n    const hasFetchedPredictions = fetchedPredictions && fetchedPredictions.length > 0;\r\n    const showDefaultPredictions = !search && !hasFetchedPredictions && useDefaultPredictions;\r\n    const geocoderVariant = getGeocoderVariant(config.maps.mapProvider);\r\n\r\n    // A list of default predictions that can be shown when the user\r\n    // focuses on the autocomplete input without typing a search. This can\r\n    // be used to reduce typing and Geocoding API calls for common\r\n    // searches.\r\n    const defaultPredictions = (config.maps.search.suggestCurrentLocation\r\n      ? [{ id: geocoderVariant.CURRENT_LOCATION_ID, predictionPlace: {} }]\r\n      : []\r\n    ).concat(config.maps.search.defaults);\r\n\r\n    return showDefaultPredictions ? defaultPredictions : fetchedPredictions;\r\n  }\r\n\r\n  // Interpret input key event\r\n  onKeyDown(e) {\r\n    if (e.keyCode === KEY_CODE_ARROW_UP) {\r\n      // Prevent changing cursor position in input\r\n      e.preventDefault();\r\n      this.changeHighlight(DIRECTION_UP);\r\n    } else if (e.keyCode === KEY_CODE_ARROW_DOWN) {\r\n      // Prevent changing cursor position in input\r\n      e.preventDefault();\r\n      this.changeHighlight(DIRECTION_DOWN);\r\n    } else if (e.keyCode === KEY_CODE_ENTER) {\r\n      const { selectedPlace } = currentValue(this.props);\r\n\r\n      if (!selectedPlace) {\r\n        // Prevent form submit, try to select value instead.\r\n        e.preventDefault();\r\n        e.stopPropagation();\r\n        this.selectItemIfNoneSelected();\r\n        this.input.blur();\r\n      }\r\n    } else if (e.keyCode === KEY_CODE_TAB) {\r\n      this.selectItemIfNoneSelected();\r\n      this.input.blur();\r\n    } else if (e.keyCode === KEY_CODE_ESC && this.input) {\r\n      this.input.blur();\r\n    }\r\n  }\r\n\r\n  // Handle input text change, fetch predictions if the value isn't empty\r\n  onChange(e) {\r\n    const onChange = this.props.input.onChange;\r\n    const predictions = this.currentPredictions();\r\n    const newValue = e.target.value;\r\n\r\n    // Clear the current values since the input content is changed\r\n    onChange({\r\n      search: newValue,\r\n      predictions: newValue ? predictions : [],\r\n      selectedPlace: null,\r\n    });\r\n\r\n    // Clear highlighted prediction since the input value changed and\r\n    // results will change as well\r\n    this.setState({ highlightedIndex: -1 });\r\n\r\n    if (!newValue) {\r\n      // No need to fetch predictions on empty input\r\n      return;\r\n    }\r\n\r\n    if (newValue.length >= 3) {\r\n      if (this.shortQueryTimeout) {\r\n        window.clearTimeout(this.shortQueryTimeout);\r\n      }\r\n      this.predict(newValue);\r\n    } else {\r\n      this.shortQueryTimeout = window.setTimeout(() => {\r\n        this.predict(newValue);\r\n      }, DEBOUNCE_WAIT_TIME_FOR_SHORT_QUERIES);\r\n    }\r\n  }\r\n\r\n  // Change the currently highlighted item by calculating the new\r\n  // index from the current state and the given direction number\r\n  // (DIRECTION_UP or DIRECTION_DOWN)\r\n  changeHighlight(direction) {\r\n    this.setState((prevState, props) => {\r\n      const predictions = this.currentPredictions();\r\n      const currentIndex = prevState.highlightedIndex;\r\n      let index = currentIndex;\r\n\r\n      if (direction === DIRECTION_UP) {\r\n        // Keep the first position if already highlighted\r\n        index = currentIndex === 0 ? 0 : currentIndex - 1;\r\n      } else if (direction === DIRECTION_DOWN) {\r\n        index = currentIndex + 1;\r\n      }\r\n\r\n      // Check that the index is within the bounds\r\n      if (index < 0) {\r\n        index = -1;\r\n      } else if (index >= predictions.length) {\r\n        index = predictions.length - 1;\r\n      }\r\n\r\n      return { highlightedIndex: index };\r\n    });\r\n  }\r\n\r\n  // Select the prediction in the given item. This will fetch/read the\r\n  // place details and set it as the selected place.\r\n  selectPrediction(prediction) {\r\n    const currentLocationBoundsDistance = this.props.config.maps?.search\r\n      ?.currentLocationBoundsDistance;\r\n    this.props.input.onChange({\r\n      ...this.props.input,\r\n      selectedPlace: null,\r\n    });\r\n\r\n    this.setState({ fetchingPlaceDetails: true });\r\n\r\n    this.getGeocoder()\r\n      .getPlaceDetails(prediction, currentLocationBoundsDistance)\r\n      .then(place => {\r\n        if (!this._isMounted) {\r\n          // Ignore if component already unmounted\r\n          return;\r\n        }\r\n        this.setState({ fetchingPlaceDetails: false });\r\n        this.props.input.onChange({\r\n          search: place.address,\r\n          predictions: [],\r\n          selectedPlace: place,\r\n        });\r\n      })\r\n      .catch(e => {\r\n        this.setState({ fetchingPlaceDetails: false });\r\n        // eslint-disable-next-line no-console\r\n        console.error(e);\r\n        this.props.input.onChange({\r\n          ...this.props.input.value,\r\n          selectedPlace: null,\r\n        });\r\n      });\r\n  }\r\n  selectItemIfNoneSelected() {\r\n    if (this.state.fetchingPredictions) {\r\n      // No need to select anything since prediction fetch is still going on\r\n      return;\r\n    }\r\n\r\n    const { search, selectedPlace } = currentValue(this.props);\r\n    const predictions = this.currentPredictions();\r\n    if (!selectedPlace) {\r\n      if (predictions && predictions.length > 0) {\r\n        const index = this.state.highlightedIndex !== -1 ? this.state.highlightedIndex : 0;\r\n        this.selectPrediction(predictions[index]);\r\n      } else {\r\n        this.predict(search);\r\n      }\r\n    }\r\n  }\r\n  predict(search) {\r\n    const config = this.props.config;\r\n    const onChange = this.props.input.onChange;\r\n    this.setState({ fetchingPredictions: true });\r\n\r\n    return this.getGeocoder()\r\n      .getPlacePredictions(search, config.maps.search.countryLimit, config.localization.locale)\r\n      .then(results => {\r\n        const { search: currentSearch } = currentValue(this.props);\r\n        this.setState({ fetchingPredictions: false });\r\n\r\n        // If the earlier predictions arrive when the user has already\r\n        // changed the search term, ignore and wait until the latest\r\n        // predictions arrive. Without this logic, results for earlier\r\n        // requests would override whatever the user had typed since.\r\n        //\r\n        // This is essentially the same as switchLatest in RxJS or\r\n        // takeLatest in Redux Saga, without canceling the earlier\r\n        // requests.\r\n        if (results.search === currentSearch) {\r\n          onChange({\r\n            search: results.search,\r\n            predictions: results.predictions,\r\n            selectedPlace: null,\r\n          });\r\n        }\r\n      })\r\n      .catch(e => {\r\n        this.setState({ fetchingPredictions: false });\r\n        // eslint-disable-next-line no-console\r\n        console.error(e);\r\n        const value = currentValue(this.props);\r\n        onChange({\r\n          ...value,\r\n          selectedPlace: null,\r\n        });\r\n      });\r\n  }\r\n\r\n  finalizeSelection() {\r\n    this.setState({ inputHasFocus: false, highlightedIndex: -1 });\r\n    this.props.input.onBlur(currentValue(this.props));\r\n  }\r\n\r\n  handleOnBlur() {\r\n    if (this.props.closeOnBlur && !this.state.selectionInProgress) {\r\n      this.finalizeSelection();\r\n    }\r\n  }\r\n\r\n  handlePredictionsSelectStart(touchCoordinates) {\r\n    this.setState({\r\n      selectionInProgress: true,\r\n      touchStartedFrom: touchCoordinates,\r\n      isSwipe: false,\r\n    });\r\n  }\r\n\r\n  handlePredictionsSelectMove(touchCoordinates) {\r\n    this.setState(prevState => {\r\n      const touchStartedFrom = prevState.touchStartedFrom;\r\n      const isTouchAction = !!touchStartedFrom;\r\n      const isSwipe = isTouchAction\r\n        ? Math.abs(touchStartedFrom.y - touchCoordinates.y) > TOUCH_TAP_RADIUS\r\n        : false;\r\n\r\n      return { selectionInProgress: false, isSwipe };\r\n    });\r\n  }\r\n\r\n  handlePredictionsSelectEnd(prediction) {\r\n    let selectAndFinalize = false;\r\n    this.setState(\r\n      prevState => {\r\n        if (!prevState.isSwipe) {\r\n          selectAndFinalize = true;\r\n        }\r\n        return { selectionInProgress: false, touchStartedFrom: null, isSwipe: false };\r\n      },\r\n      () => {\r\n        if (selectAndFinalize) {\r\n          this.selectPrediction(prediction);\r\n          this.finalizeSelection();\r\n        }\r\n      }\r\n    );\r\n  }\r\n\r\n  render() {\r\n    const {\r\n      autoFocus,\r\n      rootClassName,\r\n      className,\r\n      iconClassName,\r\n      inputClassName,\r\n      predictionsClassName,\r\n      predictionsAttributionClassName,\r\n      validClassName,\r\n      placeholder,\r\n      input,\r\n      meta,\r\n      inputRef,\r\n      disabled,\r\n      config,\r\n    } = this.props;\r\n    const { name, onFocus } = input;\r\n    const { search } = currentValue(this.props);\r\n    const { touched, valid } = meta || {};\r\n    const isValid = valid && touched;\r\n    const predictions = this.currentPredictions();\r\n\r\n    const handleOnFocus = e => {\r\n      this.setState({ inputHasFocus: true });\r\n      onFocus(e);\r\n    };\r\n\r\n    const rootClass = classNames(rootClassName || css.root, className);\r\n    const iconClass = classNames(iconClassName || css.icon);\r\n    const inputClass = classNames(inputClassName || css.input, { [validClassName]: isValid });\r\n    const predictionsClass = classNames(predictionsClassName);\r\n\r\n    // Only render predictions when the input has focus. For\r\n    // development and easier workflow with the browser devtools, you\r\n    // might want to hardcode this to `true`. Otherwise the dropdown\r\n    // list will disappear.\r\n    const renderPredictions = this.state.inputHasFocus;\r\n    const geocoderVariant = getGeocoderVariant(config.maps.mapProvider);\r\n    const GeocoderAttribution = geocoderVariant.GeocoderAttribution;\r\n\r\n    return (\r\n      <div className={rootClass}>\r\n        <div className={iconClass}>\r\n          {this.state.fetchingPlaceDetails ? (\r\n            <IconSpinner className={css.iconSpinner} />\r\n          ) : (\r\n            <IconHourGlass />\r\n          )}\r\n        </div>\r\n        <input\r\n          className={inputClass}\r\n          type=\"search\"\r\n          autoComplete=\"off\"\r\n          autoFocus={autoFocus}\r\n          placeholder={placeholder}\r\n          name={name}\r\n          value={search}\r\n          disabled={disabled || this.state.fetchingPlaceDetails}\r\n          onFocus={handleOnFocus}\r\n          onBlur={this.handleOnBlur}\r\n          onChange={this.onChange}\r\n          onKeyDown={this.onKeyDown}\r\n          ref={node => {\r\n            this.input = node;\r\n            if (inputRef) {\r\n              inputRef(node);\r\n            }\r\n          }}\r\n          data-testid=\"location-search\"\r\n        />\r\n        {renderPredictions ? (\r\n          <LocationPredictionsList\r\n            rootClassName={predictionsClass}\r\n            predictions={predictions}\r\n            currentLocationId={geocoderVariant.CURRENT_LOCATION_ID}\r\n            isGoogleMapsInUse={config.maps.mapProvider === 'googleMaps'}\r\n            geocoder={this.getGeocoder()}\r\n            highlightedIndex={this.state.highlightedIndex}\r\n            onSelectStart={this.handlePredictionsSelectStart}\r\n            onSelectMove={this.handlePredictionsSelectMove}\r\n            onSelectEnd={this.handlePredictionsSelectEnd}\r\n          >\r\n            <GeocoderAttribution className={predictionsAttributionClassName} />\r\n          </LocationPredictionsList>\r\n        ) : null}\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nconst LocationAutocompleteInputImpl = props => {\r\n  const config = useConfiguration();\r\n\r\n  return <LocationAutocompleteInputImplementation config={config} {...props} />;\r\n};\r\n\r\nLocationAutocompleteInputImpl.defaultProps = {\r\n  autoFocus: false,\r\n  closeOnBlur: true,\r\n  rootClassName: null,\r\n  className: null,\r\n  iconClassName: null,\r\n  inputClassName: null,\r\n  predictionsClassName: null,\r\n  predictionsAttributionClassName: null,\r\n  validClassName: null,\r\n  placeholder: '',\r\n  useDefaultPredictions: true,\r\n  meta: null,\r\n  inputRef: null,\r\n};\r\n\r\nLocationAutocompleteInputImpl.propTypes = {\r\n  autoFocus: bool,\r\n  rootClassName: string,\r\n  className: string,\r\n  closeOnBlur: bool,\r\n  iconClassName: string,\r\n  inputClassName: string,\r\n  predictionsClassName: string,\r\n  predictionsAttributionClassName: string,\r\n  validClassName: string,\r\n  placeholder: string,\r\n  useDefaultPredictions: bool,\r\n  input: shape({\r\n    name: string.isRequired,\r\n    value: oneOfType([\r\n      shape({\r\n        search: string,\r\n        predictions: any,\r\n        selectedPlace: propTypes.place,\r\n      }),\r\n      string,\r\n    ]),\r\n    onChange: func.isRequired,\r\n    onFocus: func.isRequired,\r\n    onBlur: func.isRequired,\r\n  }).isRequired,\r\n  meta: shape({\r\n    valid: bool.isRequired,\r\n    touched: bool.isRequired,\r\n  }),\r\n  inputRef: func,\r\n};\r\n\r\nexport default LocationAutocompleteInputImpl;\r\n","import { types as sdkTypes } from '../util/sdkLoader';\r\n\r\nconst { LatLng: SDKLatLng, LatLngBounds: SDKLatLngBounds } = sdkTypes;\r\n\r\nconst placeOrigin = place => {\r\n  if (place && place.geometry && place.geometry.location) {\r\n    return new SDKLatLng(place.geometry.location.lat(), place.geometry.location.lng());\r\n  }\r\n  return null;\r\n};\r\n\r\nconst placeBounds = place => {\r\n  if (place && place.geometry && place.geometry.viewport) {\r\n    const ne = place.geometry.viewport.getNorthEast();\r\n    const sw = place.geometry.viewport.getSouthWest();\r\n    return new SDKLatLngBounds(\r\n      new SDKLatLng(ne.lat(), ne.lng()),\r\n      new SDKLatLng(sw.lat(), sw.lng())\r\n    );\r\n  }\r\n  return null;\r\n};\r\n\r\n/**\r\n * Get a detailed place object\r\n *\r\n * @param {String} placeId - ID for a place received from the\r\n * autocomplete service\r\n * @param {String} sessionToken - token to tie different autocomplete character searches together\r\n * with getPlaceDetails call\r\n *\r\n * @return {Promise<util.propTypes.place>} Promise that\r\n * resolves to the detailed place, rejects if the request failed\r\n */\r\nexport const getPlaceDetails = (placeId, sessionToken) =>\r\n  new Promise((resolve, reject) => {\r\n    const serviceStatus = window.google.maps.places.PlacesServiceStatus;\r\n    const el = document.createElement('div');\r\n    const service = new window.google.maps.places.PlacesService(el);\r\n    const fields = ['address_component', 'formatted_address', 'geometry', 'place_id'];\r\n    const sessionTokenMaybe = sessionToken ? { sessionToken } : {};\r\n\r\n    service.getDetails({ placeId, fields, ...sessionTokenMaybe }, (place, status) => {\r\n      if (status !== serviceStatus.OK) {\r\n        reject(\r\n          new Error(`Could not get details for place id \"${placeId}\", error status was \"${status}\"`)\r\n        );\r\n      } else {\r\n        resolve({\r\n          address: place.formatted_address,\r\n          origin: placeOrigin(place),\r\n          bounds: placeBounds(place),\r\n        });\r\n      }\r\n    });\r\n  });\r\n\r\nconst predictionSuccessful = status => {\r\n  const { OK, ZERO_RESULTS } = window.google.maps.places.PlacesServiceStatus;\r\n  return status === OK || status === ZERO_RESULTS;\r\n};\r\n\r\n/**\r\n * Get place predictions for the given search\r\n *\r\n * @param {String} search - place name or address to search\r\n * @param {String} sessionToken - token to tie different autocomplete character searches together\r\n * with getPlaceDetails call\r\n * @param {Object} searchConfigurations - defines the search configurations that can be used with\r\n * the autocomplete service. Used to restrict search to specific country (or countries).\r\n *\r\n * @return {Promise<{ search, predictions[] }>} - Promise of an object\r\n * with the original search query and an array of\r\n * `google.maps.places.AutocompletePrediction` objects\r\n */\r\nexport const getPlacePredictions = (search, sessionToken, searchConfigurations) =>\r\n  new Promise((resolve, reject) => {\r\n    const service = new window.google.maps.places.AutocompleteService();\r\n    const sessionTokenMaybe = sessionToken ? { sessionToken } : {};\r\n\r\n    service.getPlacePredictions(\r\n      { input: search, ...sessionTokenMaybe, ...searchConfigurations },\r\n      (predictions, status) => {\r\n        if (!predictionSuccessful(status)) {\r\n          reject(new Error(`Prediction service status not OK: ${status}`));\r\n        } else {\r\n          const results = {\r\n            search,\r\n            predictions: predictions || [],\r\n          };\r\n          resolve(results);\r\n        }\r\n      }\r\n    );\r\n  });\r\n\r\n/**\r\n * Deprecation: use function from src/util/maps.js\r\n * Cut some precision from bounds coordinates to tackle subtle map movements\r\n * when map is moved manually\r\n *\r\n * @param {LatLngBounds} sdkBounds - bounds to be changed to fixed precision\r\n * @param {Number} fixedPrecision - integer to be used on tofixed() change.\r\n *\r\n * @return {SDKLatLngBounds} - bounds cut to given fixed precision\r\n */\r\nexport const sdkBoundsToFixedCoordinates = (sdkBounds, fixedPrecision) => {\r\n  const fixed = n => Number.parseFloat(n.toFixed(fixedPrecision));\r\n  const ne = new SDKLatLng(fixed(sdkBounds.ne.lat), fixed(sdkBounds.ne.lng));\r\n  const sw = new SDKLatLng(fixed(sdkBounds.sw.lat), fixed(sdkBounds.sw.lng));\r\n\r\n  return new SDKLatLngBounds(ne, sw);\r\n};\r\n\r\n/**\r\n * Deprecation: use function from src/util/maps.js\r\n * Check if given bounds object have the same coordinates\r\n *\r\n * @param {LatLngBounds} sdkBounds1 - bounds #1 to be compared\r\n * @param {LatLngBounds} sdkBounds2 - bounds #2 to be compared\r\n *\r\n * @return {boolean} - true if bounds are the same\r\n */\r\nexport const hasSameSDKBounds = (sdkBounds1, sdkBounds2) => {\r\n  if (!(sdkBounds1 instanceof SDKLatLngBounds) || !(sdkBounds2 instanceof SDKLatLngBounds)) {\r\n    return false;\r\n  }\r\n  return (\r\n    sdkBounds1.ne.lat === sdkBounds2.ne.lat &&\r\n    sdkBounds1.ne.lng === sdkBounds2.ne.lng &&\r\n    sdkBounds1.sw.lat === sdkBounds2.sw.lat &&\r\n    sdkBounds1.sw.lng === sdkBounds2.sw.lng\r\n  );\r\n};\r\n\r\n/**\r\n * Calculate a bounding box in the given location\r\n *\r\n * @param {latlng} center - center of the bounding box\r\n * @param {distance} distance - distance in meters from the center to\r\n * the sides of the bounding box\r\n *\r\n * @return {LatLngBounds} bounding box around the given location\r\n *\r\n */\r\nexport const locationBounds = (latlng, distance) => {\r\n  const bounds = new window.google.maps.Circle({\r\n    center: new window.google.maps.LatLng(latlng.lat, latlng.lng),\r\n    radius: distance,\r\n  }).getBounds();\r\n\r\n  const ne = bounds.getNorthEast();\r\n  const sw = bounds.getSouthWest();\r\n\r\n  return new SDKLatLngBounds(new SDKLatLng(ne.lat(), ne.lng()), new SDKLatLng(sw.lat(), sw.lng()));\r\n};\r\n\r\n/**\r\n * Helper functions for handling Google OverlayView.\r\n * Based on https://github.com/tomchentw/react-google-maps/blob/v9.4.5/src/utils/OverlayViewHelper.js\r\n *\r\n * @param {element} containerElement - map container\r\n * @param {object} props - map props\r\n * @return position offset to allow custom position for the OverlayView\r\n */\r\nexport const getOffsetOverride = (containerElement, props) => {\r\n  const { getPixelPositionOffset } = props;\r\n  //\r\n  // Allows the component to control the visual position of the OverlayView\r\n  // relative to the LatLng pixel position.\r\n  //\r\n  if (typeof getPixelPositionOffset === 'function') {\r\n    return getPixelPositionOffset(containerElement.offsetWidth, containerElement.offsetHeight);\r\n  } else {\r\n    return {};\r\n  }\r\n};\r\n\r\n/**\r\n * Helper functions for handling Google OverlayView\r\n * Based on https://github.com/tomchentw/react-google-maps/blob/v9.4.5/src/utils/OverlayViewHelper.js\r\n *\r\n * @param {MapCanvasProjection} mapCanvasProjection - map projection.\r\n * @param {object} offset - position offset on map canvas.\r\n * @param {LatLngBounds} bounds - map bounds.\r\n *\r\n * @return styles to render the overlay within the projection.\r\n */\r\nconst getLayoutStylesByBounds = (mapCanvasProjection, offset, bounds) => {\r\n  const ne = mapCanvasProjection.fromLatLngToDivPixel(bounds.getNorthEast());\r\n  const sw = mapCanvasProjection.fromLatLngToDivPixel(bounds.getSouthWest());\r\n  if (ne && sw) {\r\n    return {\r\n      left: `${sw.x + offset.x}px`,\r\n      top: `${ne.y + offset.y}px`,\r\n      width: `${ne.x - sw.x - offset.x}px`,\r\n      height: `${sw.y - ne.y - offset.y}px`,\r\n    };\r\n  }\r\n  return {\r\n    left: `-9999px`,\r\n    top: `-9999px`,\r\n  };\r\n};\r\n\r\n/**\r\n * Helper functions for handling Google OverlayView\r\n * Based on https://github.com/tomchentw/react-google-maps/blob/v9.4.5/src/utils/OverlayViewHelper.js\r\n *\r\n * @param {MapCanvasProjection} mapCanvasProjection - map projection.\r\n * @param {object} offset - position offset on map canvas.\r\n * @param {LatLng} position - map position/location.\r\n *\r\n * @return  styles to render single coordinate pair within the projection.\r\n */\r\nconst getLayoutStylesByPosition = (mapCanvasProjection, offset, position) => {\r\n  const point = mapCanvasProjection.fromLatLngToDivPixel(position);\r\n  if (point) {\r\n    const { x, y } = point;\r\n    return {\r\n      left: `${x + offset.x}px`,\r\n      top: `${y + offset.y}px`,\r\n    };\r\n  }\r\n  return {\r\n    left: `-9999px`,\r\n    top: `-9999px`,\r\n  };\r\n};\r\n\r\n/**\r\n * Helper functions for handling Google OverlayView\r\n * Based on https://github.com/tomchentw/react-google-maps/blob/v9.4.5/src/utils/OverlayViewHelper.js\r\n *\r\n * @param {MapCanvasProjection} mapCanvasProjection - map projection.\r\n * @param {object} offset - position offset on map canvas.\r\n * @param {object} props - map props.\r\n *\r\n * @return styles to render an area or a single coordinate pair within the projection.\r\n */\r\nexport const getLayoutStyles = (mapCanvasProjection, offset, props) => {\r\n  const createLatLng = (inst, Type) => {\r\n    return new Type(inst.lat, inst.lng);\r\n  };\r\n\r\n  const createLatLngBounds = (inst, Type) => {\r\n    return new Type(\r\n      new window.google.maps.LatLng(inst.ne.lat, inst.ne.lng),\r\n      new window.google.maps.LatLng(inst.sw.lat, inst.sw.lng)\r\n    );\r\n  };\r\n\r\n  const ensureOfType = (inst, type, factory) => {\r\n    if (inst instanceof type) {\r\n      return inst;\r\n    } else {\r\n      return factory(inst, type);\r\n    }\r\n  };\r\n\r\n  if (props.bounds) {\r\n    const bounds = ensureOfType(props.bounds, window.google.maps.LatLngBounds, createLatLngBounds);\r\n    return getLayoutStylesByBounds(mapCanvasProjection, offset, bounds);\r\n  } else {\r\n    const position = ensureOfType(props.position, window.google.maps.LatLng, createLatLng);\r\n    return getLayoutStylesByPosition(mapCanvasProjection, offset, position);\r\n  }\r\n};\r\n"],"names":["IconHourGlass","React","className","css","width","height","viewBox","xmlns","transform","strokeWidth","fill","fillRule","strokeLinecap","strokeLinejoin","d","cx","cy","r","IconCurrentLocation","LatLng","SDKLatLng","LatLngBounds","SDKLatLngBounds","sdkTypes","CURRENT_LOCATION_ID","PLACE_TYPE_BOUNDS_DISTANCES","address","country","region","postcode","district","place","locality","neighborhood","poi","locationBounds","latlng","distance","bounds","window","mapboxgl","LngLat","lng","lat","toBounds","getNorth","getEast","getSouth","getWest","placeOrigin","prediction","Array","isArray","center","length","placeBounds","bbox","placeType","place_type","GeocoderAttribution","getClient","mapboxSdk","Error","this","_client","accessToken","getPlacePredictions","search","countryLimit","locale","limitCountriesMaybe","countries","geocoding","forwardGeocode","query","limit","language","send","then","response","predictions","body","features","getPredictionId","id","getPredictionAddress","predictionPlace","place_name","getPlaceDetails","currentLocationBoundsDistance","userLocation","origin","Promise","resolve","props","rootClassName","classes","classNames","constructor","sessionToken","getSessionToken","google","maps","places","AutocompleteSessionToken","componentRestrictions","googleMapsUtil","results","place_id","description","DIRECTION_DOWN","getTouchCoordinates","nativeEvent","touch","changedTouches","x","screenX","y","screenY","getGeocoderVariant","mapProvider","geocoderGoogleMaps","geocoderMapbox","LocationPredictionsList","children","currentLocationId","geocoder","isGoogleMapsInUse","highlightedIndex","onSelectStart","onSelectMove","onSelectEnd","predictionRootMapProviderClass","map","item","index","isHighlighted","predictionId","key","onTouchStart","e","preventDefault","onMouseDown","onTouchMove","onTouchEnd","onMouseUp","FormattedMessage","defaultProps","currentValue","value","input","selectedPlace","LocationAutocompleteInputImplementation","Component","super","_isMounted","state","inputHasFocus","selectionInProgress","touchStartedFrom","fetchingPlaceDetails","fetchingPredictions","shortQueryTimeout","getGeocoder","bind","currentPredictions","changeHighlight","selectPrediction","selectItemIfNoneSelected","onKeyDown","onChange","handleOnBlur","handlePredictionsSelectStart","handlePredictionsSelectMove","handlePredictionsSelectEnd","finalizeSelection","predict","debounce","leading","componentDidMount","componentWillUnmount","clearTimeout","Geocoder","config","default","_geocoder","fetchedPredictions","useDefaultPredictions","hasFetchedPredictions","showDefaultPredictions","geocoderVariant","defaultPredictions","suggestCurrentLocation","concat","defaults","keyCode","stopPropagation","blur","newValue","target","setState","setTimeout","direction","prevState","currentIndex","_this$props$config$ma","_this$props$config$ma2","catch","console","error","localization","currentSearch","onBlur","closeOnBlur","touchCoordinates","isSwipe","Math","abs","selectAndFinalize","render","autoFocus","iconClassName","inputClassName","predictionsClassName","predictionsAttributionClassName","validClassName","placeholder","meta","inputRef","disabled","name","onFocus","touched","valid","isValid","rootClass","iconClass","inputClass","predictionsClass","renderPredictions","IconSpinner","type","autoComplete","ref","node","LocationAutocompleteInputImpl","useConfiguration","Object","assign","geometry","location","viewport","ne","getNorthEast","sw","getSouthWest","placeId","reject","serviceStatus","PlacesServiceStatus","el","document","createElement","service","PlacesService","sessionTokenMaybe","getDetails","fields","status","OK","formatted_address","searchConfigurations","AutocompleteService","ZERO_RESULTS","predictionSuccessful","Circle","radius","getBounds","getOffsetOverride","containerElement","getPixelPositionOffset","offsetWidth","offsetHeight","getLayoutStyles","mapCanvasProjection","offset","createLatLng","inst","Type","createLatLngBounds","ensureOfType","factory","getLayoutStylesByBounds","fromLatLngToDivPixel","left","top","getLayoutStylesByPosition","position","point"],"sourceRoot":""}